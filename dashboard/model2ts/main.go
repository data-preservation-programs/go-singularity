package main

import (
	"fmt"
	"os"
	"reflect"
	"strings"
	"time"

	"github.com/data-preservation-programs/singularity/model"
	"github.com/ipfs/go-cid"
	"github.com/rjNemo/underscore"
)

//go:generate go run .

func main() {
	definitions := []string{
		"// Code generated by model2ts. DO NOT EDIT.",
	}
	k := []string{"WorkType", "WorkState", "DealState", "ScheduleState"}
	m := [][]string{
		underscore.Map(model.WorkTypes, func(w model.WorkType) string { return "'" + string(w) + "'" }),
		underscore.Map(model.WorkStates, func(w model.WorkState) string { return "'" + string(w) + "'" }),
		underscore.Map(model.DealStates, func(w model.DealState) string { return "'" + string(w) + "'" }),
		underscore.Map(model.ScheduleStates, func(w model.ScheduleState) string { return "'" + string(w) + "'" }),
	}
	for i := range k {
		definitions = append(definitions, fmt.Sprintf("export type %s = %s", k[i], strings.Join(m[i], " | ")))
	}

	for _, value := range model.Tables {
		tp := reflect.TypeOf(value).Elem()
		ts := generateTypeScript(tp)
		definitions = append(definitions, ts)
	}
	err := os.WriteFile("../src/model/model.ts", []byte(strings.Join(definitions, "\n")), 0644)
	if err != nil {
		panic(err)
	}
}

func resolveType(t reflect.Type) string {
	switch t {
	case reflect.TypeOf(model.WorkType("")):
		return "WorkType"
	case reflect.TypeOf(model.WorkState("")):
		return "WorkState"
	case reflect.TypeOf(model.DealState("")):
		return "DealState"
	case reflect.TypeOf(model.ScheduleState("")):
		return "ScheduleState"
	case reflect.TypeOf(model.CID(cid.Cid{})):
		return "string"
	case reflect.TypeOf(model.Metadata(map[string]string{})):
		return "{[key: string]: string}"
	case reflect.TypeOf(model.StringSlice([]string{})):
		return "string[]"
	default:
		switch t.Kind() {
		case reflect.Bool:
			return "boolean"
		case reflect.Int, reflect.Uint32, reflect.Int64, reflect.Uint64, reflect.Int32, reflect.Float64, reflect.Float32:
			return "number"
		case reflect.String:
			return "string"
		case reflect.Struct:
			if t == reflect.TypeOf(time.Time{}) {
				return "Date"
			}
			return t.Name()
		case reflect.Slice:
			if t == reflect.TypeOf([]byte{}) {
				return "string"
			}
			sliceType := t.Elem()
			return sliceType.Name() + "[]"
		case reflect.Ptr:
			return resolveType(t.Elem())
		}
	}
	return ""
}

func generateTypeScript(t reflect.Type) string {
	var fields []string
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		tag := field.Tag.Get("json")
		if strings.HasPrefix(tag, "-") {
			continue
		}
		if !field.IsExported() {
			continue
		}
		name := strings.Split(tag, ",")[0]
		if name == "" {
			panic(fmt.Errorf("no name for %s", field.Name))
		}
		omitempty := strings.Contains(tag, "omitempty")
		tsType := resolveType(field.Type)
		f := fmt.Sprintf("%s: %s", name, tsType)
		if tsType == "" {
			panic(fmt.Errorf("no type for %s", field.Type))
		}
		if omitempty {
			f += " | undefined"
		}
		fields = append(fields, f)
	}
	return fmt.Sprintf("export interface %s {\n\t%s\n}", t.Name(), strings.Join(fields, "\n\t"))
}
